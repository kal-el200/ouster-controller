// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STREAMINGINFO_OUSTER_OSF_V2_H_
#define FLATBUFFERS_GENERATED_STREAMINGINFO_OUSTER_OSF_V2_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ouster {
namespace osf {
namespace v2 {

struct StreamStats;
struct StreamStatsBuilder;

struct ChunkInfo;
struct ChunkInfoBuilder;

struct StreamingInfo;
struct StreamingInfoBuilder;

struct StreamStats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StreamStatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_START_TS = 6,
    VT_END_TS = 8,
    VT_MESSAGE_COUNT = 10,
    VT_MESSAGE_AVG_SIZE = 12,
    VT_RECEIVE_TIMESTAMPS = 14,
    VT_SENSOR_TIMESTAMPS = 16
  };
  uint32_t stream_id() const {
    return GetField<uint32_t>(VT_STREAM_ID, 0);
  }
  uint64_t start_ts() const {
    return GetField<uint64_t>(VT_START_TS, 0);
  }
  uint64_t end_ts() const {
    return GetField<uint64_t>(VT_END_TS, 0);
  }
  uint64_t message_count() const {
    return GetField<uint64_t>(VT_MESSAGE_COUNT, 0);
  }
  uint32_t message_avg_size() const {
    return GetField<uint32_t>(VT_MESSAGE_AVG_SIZE, 0);
  }
  const ::flatbuffers::Vector<uint64_t> *receive_timestamps() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_RECEIVE_TIMESTAMPS);
  }
  const ::flatbuffers::Vector<uint64_t> *sensor_timestamps() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_SENSOR_TIMESTAMPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STREAM_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_START_TS, 8) &&
           VerifyField<uint64_t>(verifier, VT_END_TS, 8) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_COUNT, 8) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_AVG_SIZE, 4) &&
           VerifyOffset(verifier, VT_RECEIVE_TIMESTAMPS) &&
           verifier.VerifyVector(receive_timestamps()) &&
           VerifyOffset(verifier, VT_SENSOR_TIMESTAMPS) &&
           verifier.VerifyVector(sensor_timestamps()) &&
           verifier.EndTable();
  }
};

struct StreamStatsBuilder {
  typedef StreamStats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stream_id(uint32_t stream_id) {
    fbb_.AddElement<uint32_t>(StreamStats::VT_STREAM_ID, stream_id, 0);
  }
  void add_start_ts(uint64_t start_ts) {
    fbb_.AddElement<uint64_t>(StreamStats::VT_START_TS, start_ts, 0);
  }
  void add_end_ts(uint64_t end_ts) {
    fbb_.AddElement<uint64_t>(StreamStats::VT_END_TS, end_ts, 0);
  }
  void add_message_count(uint64_t message_count) {
    fbb_.AddElement<uint64_t>(StreamStats::VT_MESSAGE_COUNT, message_count, 0);
  }
  void add_message_avg_size(uint32_t message_avg_size) {
    fbb_.AddElement<uint32_t>(StreamStats::VT_MESSAGE_AVG_SIZE, message_avg_size, 0);
  }
  void add_receive_timestamps(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> receive_timestamps) {
    fbb_.AddOffset(StreamStats::VT_RECEIVE_TIMESTAMPS, receive_timestamps);
  }
  void add_sensor_timestamps(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> sensor_timestamps) {
    fbb_.AddOffset(StreamStats::VT_SENSOR_TIMESTAMPS, sensor_timestamps);
  }
  explicit StreamStatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StreamStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StreamStats>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StreamStats> CreateStreamStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t stream_id = 0,
    uint64_t start_ts = 0,
    uint64_t end_ts = 0,
    uint64_t message_count = 0,
    uint32_t message_avg_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> receive_timestamps = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> sensor_timestamps = 0) {
  StreamStatsBuilder builder_(_fbb);
  builder_.add_message_count(message_count);
  builder_.add_end_ts(end_ts);
  builder_.add_start_ts(start_ts);
  builder_.add_sensor_timestamps(sensor_timestamps);
  builder_.add_receive_timestamps(receive_timestamps);
  builder_.add_message_avg_size(message_avg_size);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StreamStats> CreateStreamStatsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t stream_id = 0,
    uint64_t start_ts = 0,
    uint64_t end_ts = 0,
    uint64_t message_count = 0,
    uint32_t message_avg_size = 0,
    const std::vector<uint64_t> *receive_timestamps = nullptr,
    const std::vector<uint64_t> *sensor_timestamps = nullptr) {
  auto receive_timestamps__ = receive_timestamps ? _fbb.CreateVector<uint64_t>(*receive_timestamps) : 0;
  auto sensor_timestamps__ = sensor_timestamps ? _fbb.CreateVector<uint64_t>(*sensor_timestamps) : 0;
  return ouster::osf::v2::CreateStreamStats(
      _fbb,
      stream_id,
      start_ts,
      end_ts,
      message_count,
      message_avg_size,
      receive_timestamps__,
      sensor_timestamps__);
}

struct ChunkInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_STREAM_ID = 6,
    VT_MESSAGE_COUNT = 8
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint32_t stream_id() const {
    return GetField<uint32_t>(VT_STREAM_ID, 0);
  }
  uint32_t message_count() const {
    return GetField<uint32_t>(VT_MESSAGE_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_STREAM_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct ChunkInfoBuilder {
  typedef ChunkInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(ChunkInfo::VT_OFFSET, offset, 0);
  }
  void add_stream_id(uint32_t stream_id) {
    fbb_.AddElement<uint32_t>(ChunkInfo::VT_STREAM_ID, stream_id, 0);
  }
  void add_message_count(uint32_t message_count) {
    fbb_.AddElement<uint32_t>(ChunkInfo::VT_MESSAGE_COUNT, message_count, 0);
  }
  explicit ChunkInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkInfo> CreateChunkInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0,
    uint32_t stream_id = 0,
    uint32_t message_count = 0) {
  ChunkInfoBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_message_count(message_count);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct StreamingInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StreamingInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNKS = 4,
    VT_STREAM_STATS = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChunkInfo>> *chunks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChunkInfo>> *>(VT_CHUNKS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::StreamStats>> *stream_stats() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::StreamStats>> *>(VT_STREAM_STATS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.VerifyVector(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           VerifyOffset(verifier, VT_STREAM_STATS) &&
           verifier.VerifyVector(stream_stats()) &&
           verifier.VerifyVectorOfTables(stream_stats()) &&
           verifier.EndTable();
  }
};

struct StreamingInfoBuilder {
  typedef StreamingInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chunks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChunkInfo>>> chunks) {
    fbb_.AddOffset(StreamingInfo::VT_CHUNKS, chunks);
  }
  void add_stream_stats(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::StreamStats>>> stream_stats) {
    fbb_.AddOffset(StreamingInfo::VT_STREAM_STATS, stream_stats);
  }
  explicit StreamingInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StreamingInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StreamingInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StreamingInfo> CreateStreamingInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChunkInfo>>> chunks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::StreamStats>>> stream_stats = 0) {
  StreamingInfoBuilder builder_(_fbb);
  builder_.add_stream_stats(stream_stats);
  builder_.add_chunks(chunks);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StreamingInfo> CreateStreamingInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ouster::osf::v2::ChunkInfo>> *chunks = nullptr,
    const std::vector<::flatbuffers::Offset<ouster::osf::v2::StreamStats>> *stream_stats = nullptr) {
  auto chunks__ = chunks ? _fbb.CreateVector<::flatbuffers::Offset<ouster::osf::v2::ChunkInfo>>(*chunks) : 0;
  auto stream_stats__ = stream_stats ? _fbb.CreateVector<::flatbuffers::Offset<ouster::osf::v2::StreamStats>>(*stream_stats) : 0;
  return ouster::osf::v2::CreateStreamingInfo(
      _fbb,
      chunks__,
      stream_stats__);
}

inline const ouster::osf::v2::StreamingInfo *GetStreamingInfo(const void *buf) {
  return ::flatbuffers::GetRoot<ouster::osf::v2::StreamingInfo>(buf);
}

inline const ouster::osf::v2::StreamingInfo *GetSizePrefixedStreamingInfo(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ouster::osf::v2::StreamingInfo>(buf);
}

inline bool VerifyStreamingInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ouster::osf::v2::StreamingInfo>(nullptr);
}

inline bool VerifySizePrefixedStreamingInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ouster::osf::v2::StreamingInfo>(nullptr);
}

inline void FinishStreamingInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ouster::osf::v2::StreamingInfo> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStreamingInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ouster::osf::v2::StreamingInfo> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace v2
}  // namespace osf
}  // namespace ouster

#endif  // FLATBUFFERS_GENERATED_STREAMINGINFO_OUSTER_OSF_V2_H_
