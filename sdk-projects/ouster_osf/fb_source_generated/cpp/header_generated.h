// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HEADER_OUSTER_OSF_V2_H_
#define FLATBUFFERS_GENERATED_HEADER_OUSTER_OSF_V2_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ouster {
namespace osf {
namespace v2 {

struct Header;
struct HeaderBuilder;

enum class HEADER_STATUS : uint8_t {
  UNKNOWN = 0,
  INVALID = 1,
  VALID = 2,
  MIN = UNKNOWN,
  MAX = VALID
};

inline const HEADER_STATUS (&EnumValuesHEADER_STATUS())[3] {
  static const HEADER_STATUS values[] = {
    HEADER_STATUS::UNKNOWN,
    HEADER_STATUS::INVALID,
    HEADER_STATUS::VALID
  };
  return values;
}

inline const char * const *EnumNamesHEADER_STATUS() {
  static const char * const names[4] = {
    "UNKNOWN",
    "INVALID",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNameHEADER_STATUS(HEADER_STATUS e) {
  if (::flatbuffers::IsOutRange(e, HEADER_STATUS::UNKNOWN, HEADER_STATUS::VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHEADER_STATUS()[index];
}

struct Header FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STATUS = 6,
    VT_METADATA_OFFSET = 8,
    VT_FILE_LENGTH = 10
  };
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  ouster::osf::v2::HEADER_STATUS status() const {
    return static_cast<ouster::osf::v2::HEADER_STATUS>(GetField<uint8_t>(VT_STATUS, 0));
  }
  uint64_t metadata_offset() const {
    return GetField<uint64_t>(VT_METADATA_OFFSET, 1ULL);
  }
  uint64_t file_length() const {
    return GetField<uint64_t>(VT_FILE_LENGTH, 1ULL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VERSION, 8) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint64_t>(verifier, VT_METADATA_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_FILE_LENGTH, 8) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  typedef Header Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(Header::VT_VERSION, version, 0);
  }
  void add_status(ouster::osf::v2::HEADER_STATUS status) {
    fbb_.AddElement<uint8_t>(Header::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_metadata_offset(uint64_t metadata_offset) {
    fbb_.AddElement<uint64_t>(Header::VT_METADATA_OFFSET, metadata_offset, 1ULL);
  }
  void add_file_length(uint64_t file_length) {
    fbb_.AddElement<uint64_t>(Header::VT_FILE_LENGTH, file_length, 1ULL);
  }
  explicit HeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Header> CreateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t version = 0,
    ouster::osf::v2::HEADER_STATUS status = ouster::osf::v2::HEADER_STATUS::UNKNOWN,
    uint64_t metadata_offset = 1ULL,
    uint64_t file_length = 1ULL) {
  HeaderBuilder builder_(_fbb);
  builder_.add_file_length(file_length);
  builder_.add_metadata_offset(metadata_offset);
  builder_.add_version(version);
  builder_.add_status(status);
  return builder_.Finish();
}

inline const ouster::osf::v2::Header *GetHeader(const void *buf) {
  return ::flatbuffers::GetRoot<ouster::osf::v2::Header>(buf);
}

inline const ouster::osf::v2::Header *GetSizePrefixedHeader(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ouster::osf::v2::Header>(buf);
}

inline const char *HeaderIdentifier() {
  return "OSF$";
}

inline bool HeaderBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HeaderIdentifier());
}

inline bool SizePrefixedHeaderBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HeaderIdentifier(), true);
}

inline bool VerifyHeaderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ouster::osf::v2::Header>(HeaderIdentifier());
}

inline bool VerifySizePrefixedHeaderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ouster::osf::v2::Header>(HeaderIdentifier());
}

inline const char *HeaderExtension() {
  return "osfh";
}

inline void FinishHeaderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ouster::osf::v2::Header> root) {
  fbb.Finish(root, HeaderIdentifier());
}

inline void FinishSizePrefixedHeaderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ouster::osf::v2::Header> root) {
  fbb.FinishSizePrefixed(root, HeaderIdentifier());
}

}  // namespace v2
}  // namespace osf
}  // namespace ouster

#endif  // FLATBUFFERS_GENERATED_HEADER_OUSTER_OSF_V2_H_
