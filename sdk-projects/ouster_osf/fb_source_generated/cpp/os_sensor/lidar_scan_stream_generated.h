// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LIDARSCANSTREAM_OUSTER_OSF_V2_H_
#define FLATBUFFERS_GENERATED_LIDARSCANSTREAM_OUSTER_OSF_V2_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ouster {
namespace osf {
namespace v2 {

struct ChannelData;
struct ChannelDataBuilder;

struct ChannelField;

struct LidarScanMsg;
struct LidarScanMsgBuilder;

struct LidarScanStream;
struct LidarScanStreamBuilder;

enum class CHAN_FIELD : uint8_t {
  UNKNOWN = 0,
  RANGE = 1,
  RANGE2 = 2,
  SIGNAL = 3,
  SIGNAL2 = 4,
  REFLECTIVITY = 5,
  REFLECTIVITY2 = 6,
  NEAR_IR = 7,
  FLAGS = 8,
  FLAGS2 = 9,
  RAW_HEADERS = 40,
  RAW32_WORD5 = 45,
  RAW32_WORD6 = 46,
  RAW32_WORD7 = 47,
  RAW32_WORD8 = 48,
  RAW32_WORD9 = 49,
  CUSTOM0 = 50,
  CUSTOM1 = 51,
  CUSTOM2 = 52,
  CUSTOM3 = 53,
  CUSTOM4 = 54,
  CUSTOM5 = 55,
  CUSTOM6 = 56,
  CUSTOM7 = 57,
  CUSTOM8 = 58,
  CUSTOM9 = 59,
  RAW32_WORD1 = 60,
  RAW32_WORD2 = 61,
  RAW32_WORD3 = 62,
  RAW32_WORD4 = 63,
  MIN = UNKNOWN,
  MAX = RAW32_WORD4
};

inline const CHAN_FIELD (&EnumValuesCHAN_FIELD())[30] {
  static const CHAN_FIELD values[] = {
    CHAN_FIELD::UNKNOWN,
    CHAN_FIELD::RANGE,
    CHAN_FIELD::RANGE2,
    CHAN_FIELD::SIGNAL,
    CHAN_FIELD::SIGNAL2,
    CHAN_FIELD::REFLECTIVITY,
    CHAN_FIELD::REFLECTIVITY2,
    CHAN_FIELD::NEAR_IR,
    CHAN_FIELD::FLAGS,
    CHAN_FIELD::FLAGS2,
    CHAN_FIELD::RAW_HEADERS,
    CHAN_FIELD::RAW32_WORD5,
    CHAN_FIELD::RAW32_WORD6,
    CHAN_FIELD::RAW32_WORD7,
    CHAN_FIELD::RAW32_WORD8,
    CHAN_FIELD::RAW32_WORD9,
    CHAN_FIELD::CUSTOM0,
    CHAN_FIELD::CUSTOM1,
    CHAN_FIELD::CUSTOM2,
    CHAN_FIELD::CUSTOM3,
    CHAN_FIELD::CUSTOM4,
    CHAN_FIELD::CUSTOM5,
    CHAN_FIELD::CUSTOM6,
    CHAN_FIELD::CUSTOM7,
    CHAN_FIELD::CUSTOM8,
    CHAN_FIELD::CUSTOM9,
    CHAN_FIELD::RAW32_WORD1,
    CHAN_FIELD::RAW32_WORD2,
    CHAN_FIELD::RAW32_WORD3,
    CHAN_FIELD::RAW32_WORD4
  };
  return values;
}

inline const char * const *EnumNamesCHAN_FIELD() {
  static const char * const names[65] = {
    "UNKNOWN",
    "RANGE",
    "RANGE2",
    "SIGNAL",
    "SIGNAL2",
    "REFLECTIVITY",
    "REFLECTIVITY2",
    "NEAR_IR",
    "FLAGS",
    "FLAGS2",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "RAW_HEADERS",
    "",
    "",
    "",
    "",
    "RAW32_WORD5",
    "RAW32_WORD6",
    "RAW32_WORD7",
    "RAW32_WORD8",
    "RAW32_WORD9",
    "CUSTOM0",
    "CUSTOM1",
    "CUSTOM2",
    "CUSTOM3",
    "CUSTOM4",
    "CUSTOM5",
    "CUSTOM6",
    "CUSTOM7",
    "CUSTOM8",
    "CUSTOM9",
    "RAW32_WORD1",
    "RAW32_WORD2",
    "RAW32_WORD3",
    "RAW32_WORD4",
    nullptr
  };
  return names;
}

inline const char *EnumNameCHAN_FIELD(CHAN_FIELD e) {
  if (::flatbuffers::IsOutRange(e, CHAN_FIELD::UNKNOWN, CHAN_FIELD::RAW32_WORD4)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCHAN_FIELD()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ChannelField FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t chan_field_;
  uint8_t chan_field_type_;

 public:
  ChannelField()
      : chan_field_(0),
        chan_field_type_(0) {
  }
  ChannelField(ouster::osf::v2::CHAN_FIELD _chan_field, ouster::osf::v2::CHAN_FIELD_TYPE _chan_field_type)
      : chan_field_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_chan_field))),
        chan_field_type_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_chan_field_type))) {
  }
  ouster::osf::v2::CHAN_FIELD chan_field() const {
    return static_cast<ouster::osf::v2::CHAN_FIELD>(::flatbuffers::EndianScalar(chan_field_));
  }
  ouster::osf::v2::CHAN_FIELD_TYPE chan_field_type() const {
    return static_cast<ouster::osf::v2::CHAN_FIELD_TYPE>(::flatbuffers::EndianScalar(chan_field_type_));
  }
};
FLATBUFFERS_STRUCT_END(ChannelField, 2);

struct ChannelData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChannelDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct ChannelDataBuilder {
  typedef ChannelData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(ChannelData::VT_BUFFER, buffer);
  }
  explicit ChannelDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelData> CreateChannelData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer = 0) {
  ChannelDataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChannelData> CreateChannelDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return ouster::osf::v2::CreateChannelData(
      _fbb,
      buffer__);
}

struct LidarScanMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LidarScanMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_FIELD_TYPES = 6,
    VT_HEADER_TIMESTAMP = 8,
    VT_HEADER_MEASUREMENT_ID = 10,
    VT_HEADER_STATUS = 12,
    VT_FRAME_ID = 14,
    VT_POSE = 16,
    VT_PACKET_TIMESTAMP = 18,
    VT_CUSTOM_FIELDS = 20,
    VT_FRAME_STATUS = 22,
    VT_SHUTDOWN_COUNTDOWN = 24,
    VT_SHOT_LIMITING_COUNTDOWN = 26,
    VT_ALERT_FLAGS = 28
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChannelData>> *channels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChannelData>> *>(VT_CHANNELS);
  }
  const ::flatbuffers::Vector<const ouster::osf::v2::ChannelField *> *field_types() const {
    return GetPointer<const ::flatbuffers::Vector<const ouster::osf::v2::ChannelField *> *>(VT_FIELD_TYPES);
  }
  const ::flatbuffers::Vector<uint64_t> *header_timestamp() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_HEADER_TIMESTAMP);
  }
  const ::flatbuffers::Vector<uint16_t> *header_measurement_id() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_HEADER_MEASUREMENT_ID);
  }
  const ::flatbuffers::Vector<uint32_t> *header_status() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_HEADER_STATUS);
  }
  int32_t frame_id() const {
    return GetField<int32_t>(VT_FRAME_ID, 0);
  }
  const ::flatbuffers::Vector<double> *pose() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSE);
  }
  const ::flatbuffers::Vector<uint64_t> *packet_timestamp() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_PACKET_TIMESTAMP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::Field>> *custom_fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::Field>> *>(VT_CUSTOM_FIELDS);
  }
  uint64_t frame_status() const {
    return GetField<uint64_t>(VT_FRAME_STATUS, 0);
  }
  uint8_t shutdown_countdown() const {
    return GetField<uint8_t>(VT_SHUTDOWN_COUNTDOWN, 0);
  }
  uint8_t shot_limiting_countdown() const {
    return GetField<uint8_t>(VT_SHOT_LIMITING_COUNTDOWN, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *alert_flags() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ALERT_FLAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           VerifyOffset(verifier, VT_FIELD_TYPES) &&
           verifier.VerifyVector(field_types()) &&
           VerifyOffset(verifier, VT_HEADER_TIMESTAMP) &&
           verifier.VerifyVector(header_timestamp()) &&
           VerifyOffset(verifier, VT_HEADER_MEASUREMENT_ID) &&
           verifier.VerifyVector(header_measurement_id()) &&
           VerifyOffset(verifier, VT_HEADER_STATUS) &&
           verifier.VerifyVector(header_status()) &&
           VerifyField<int32_t>(verifier, VT_FRAME_ID, 4) &&
           VerifyOffset(verifier, VT_POSE) &&
           verifier.VerifyVector(pose()) &&
           VerifyOffset(verifier, VT_PACKET_TIMESTAMP) &&
           verifier.VerifyVector(packet_timestamp()) &&
           VerifyOffset(verifier, VT_CUSTOM_FIELDS) &&
           verifier.VerifyVector(custom_fields()) &&
           verifier.VerifyVectorOfTables(custom_fields()) &&
           VerifyField<uint64_t>(verifier, VT_FRAME_STATUS, 8) &&
           VerifyField<uint8_t>(verifier, VT_SHUTDOWN_COUNTDOWN, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHOT_LIMITING_COUNTDOWN, 1) &&
           VerifyOffset(verifier, VT_ALERT_FLAGS) &&
           verifier.VerifyVector(alert_flags()) &&
           verifier.EndTable();
  }
};

struct LidarScanMsgBuilder {
  typedef LidarScanMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_channels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChannelData>>> channels) {
    fbb_.AddOffset(LidarScanMsg::VT_CHANNELS, channels);
  }
  void add_field_types(::flatbuffers::Offset<::flatbuffers::Vector<const ouster::osf::v2::ChannelField *>> field_types) {
    fbb_.AddOffset(LidarScanMsg::VT_FIELD_TYPES, field_types);
  }
  void add_header_timestamp(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> header_timestamp) {
    fbb_.AddOffset(LidarScanMsg::VT_HEADER_TIMESTAMP, header_timestamp);
  }
  void add_header_measurement_id(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> header_measurement_id) {
    fbb_.AddOffset(LidarScanMsg::VT_HEADER_MEASUREMENT_ID, header_measurement_id);
  }
  void add_header_status(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> header_status) {
    fbb_.AddOffset(LidarScanMsg::VT_HEADER_STATUS, header_status);
  }
  void add_frame_id(int32_t frame_id) {
    fbb_.AddElement<int32_t>(LidarScanMsg::VT_FRAME_ID, frame_id, 0);
  }
  void add_pose(::flatbuffers::Offset<::flatbuffers::Vector<double>> pose) {
    fbb_.AddOffset(LidarScanMsg::VT_POSE, pose);
  }
  void add_packet_timestamp(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> packet_timestamp) {
    fbb_.AddOffset(LidarScanMsg::VT_PACKET_TIMESTAMP, packet_timestamp);
  }
  void add_custom_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::Field>>> custom_fields) {
    fbb_.AddOffset(LidarScanMsg::VT_CUSTOM_FIELDS, custom_fields);
  }
  void add_frame_status(uint64_t frame_status) {
    fbb_.AddElement<uint64_t>(LidarScanMsg::VT_FRAME_STATUS, frame_status, 0);
  }
  void add_shutdown_countdown(uint8_t shutdown_countdown) {
    fbb_.AddElement<uint8_t>(LidarScanMsg::VT_SHUTDOWN_COUNTDOWN, shutdown_countdown, 0);
  }
  void add_shot_limiting_countdown(uint8_t shot_limiting_countdown) {
    fbb_.AddElement<uint8_t>(LidarScanMsg::VT_SHOT_LIMITING_COUNTDOWN, shot_limiting_countdown, 0);
  }
  void add_alert_flags(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> alert_flags) {
    fbb_.AddOffset(LidarScanMsg::VT_ALERT_FLAGS, alert_flags);
  }
  explicit LidarScanMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LidarScanMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LidarScanMsg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LidarScanMsg> CreateLidarScanMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::ChannelData>>> channels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const ouster::osf::v2::ChannelField *>> field_types = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> header_timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> header_measurement_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> header_status = 0,
    int32_t frame_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> pose = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> packet_timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ouster::osf::v2::Field>>> custom_fields = 0,
    uint64_t frame_status = 0,
    uint8_t shutdown_countdown = 0,
    uint8_t shot_limiting_countdown = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> alert_flags = 0) {
  LidarScanMsgBuilder builder_(_fbb);
  builder_.add_frame_status(frame_status);
  builder_.add_alert_flags(alert_flags);
  builder_.add_custom_fields(custom_fields);
  builder_.add_packet_timestamp(packet_timestamp);
  builder_.add_pose(pose);
  builder_.add_frame_id(frame_id);
  builder_.add_header_status(header_status);
  builder_.add_header_measurement_id(header_measurement_id);
  builder_.add_header_timestamp(header_timestamp);
  builder_.add_field_types(field_types);
  builder_.add_channels(channels);
  builder_.add_shot_limiting_countdown(shot_limiting_countdown);
  builder_.add_shutdown_countdown(shutdown_countdown);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LidarScanMsg> CreateLidarScanMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ouster::osf::v2::ChannelData>> *channels = nullptr,
    const std::vector<ouster::osf::v2::ChannelField> *field_types = nullptr,
    const std::vector<uint64_t> *header_timestamp = nullptr,
    const std::vector<uint16_t> *header_measurement_id = nullptr,
    const std::vector<uint32_t> *header_status = nullptr,
    int32_t frame_id = 0,
    const std::vector<double> *pose = nullptr,
    const std::vector<uint64_t> *packet_timestamp = nullptr,
    const std::vector<::flatbuffers::Offset<ouster::osf::v2::Field>> *custom_fields = nullptr,
    uint64_t frame_status = 0,
    uint8_t shutdown_countdown = 0,
    uint8_t shot_limiting_countdown = 0,
    const std::vector<uint8_t> *alert_flags = nullptr) {
  auto channels__ = channels ? _fbb.CreateVector<::flatbuffers::Offset<ouster::osf::v2::ChannelData>>(*channels) : 0;
  auto field_types__ = field_types ? _fbb.CreateVectorOfStructs<ouster::osf::v2::ChannelField>(*field_types) : 0;
  auto header_timestamp__ = header_timestamp ? _fbb.CreateVector<uint64_t>(*header_timestamp) : 0;
  auto header_measurement_id__ = header_measurement_id ? _fbb.CreateVector<uint16_t>(*header_measurement_id) : 0;
  auto header_status__ = header_status ? _fbb.CreateVector<uint32_t>(*header_status) : 0;
  auto pose__ = pose ? _fbb.CreateVector<double>(*pose) : 0;
  auto packet_timestamp__ = packet_timestamp ? _fbb.CreateVector<uint64_t>(*packet_timestamp) : 0;
  auto custom_fields__ = custom_fields ? _fbb.CreateVector<::flatbuffers::Offset<ouster::osf::v2::Field>>(*custom_fields) : 0;
  auto alert_flags__ = alert_flags ? _fbb.CreateVector<uint8_t>(*alert_flags) : 0;
  return ouster::osf::v2::CreateLidarScanMsg(
      _fbb,
      channels__,
      field_types__,
      header_timestamp__,
      header_measurement_id__,
      header_status__,
      frame_id,
      pose__,
      packet_timestamp__,
      custom_fields__,
      frame_status,
      shutdown_countdown,
      shot_limiting_countdown,
      alert_flags__);
}

struct LidarScanStream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LidarScanStreamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_ID = 4,
    VT_FIELD_TYPES = 6
  };
  uint32_t sensor_id() const {
    return GetField<uint32_t>(VT_SENSOR_ID, 0);
  }
  const ::flatbuffers::Vector<const ouster::osf::v2::ChannelField *> *field_types() const {
    return GetPointer<const ::flatbuffers::Vector<const ouster::osf::v2::ChannelField *> *>(VT_FIELD_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SENSOR_ID, 4) &&
           VerifyOffset(verifier, VT_FIELD_TYPES) &&
           verifier.VerifyVector(field_types()) &&
           verifier.EndTable();
  }
};

struct LidarScanStreamBuilder {
  typedef LidarScanStream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensor_id(uint32_t sensor_id) {
    fbb_.AddElement<uint32_t>(LidarScanStream::VT_SENSOR_ID, sensor_id, 0);
  }
  void add_field_types(::flatbuffers::Offset<::flatbuffers::Vector<const ouster::osf::v2::ChannelField *>> field_types) {
    fbb_.AddOffset(LidarScanStream::VT_FIELD_TYPES, field_types);
  }
  explicit LidarScanStreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LidarScanStream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LidarScanStream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LidarScanStream> CreateLidarScanStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sensor_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const ouster::osf::v2::ChannelField *>> field_types = 0) {
  LidarScanStreamBuilder builder_(_fbb);
  builder_.add_field_types(field_types);
  builder_.add_sensor_id(sensor_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LidarScanStream> CreateLidarScanStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sensor_id = 0,
    const std::vector<ouster::osf::v2::ChannelField> *field_types = nullptr) {
  auto field_types__ = field_types ? _fbb.CreateVectorOfStructs<ouster::osf::v2::ChannelField>(*field_types) : 0;
  return ouster::osf::v2::CreateLidarScanStream(
      _fbb,
      sensor_id,
      field_types__);
}

inline const ouster::osf::v2::LidarScanStream *GetLidarScanStream(const void *buf) {
  return ::flatbuffers::GetRoot<ouster::osf::v2::LidarScanStream>(buf);
}

inline const ouster::osf::v2::LidarScanStream *GetSizePrefixedLidarScanStream(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ouster::osf::v2::LidarScanStream>(buf);
}

inline const char *LidarScanStreamIdentifier() {
  return "oLSS";
}

inline bool LidarScanStreamBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LidarScanStreamIdentifier());
}

inline bool SizePrefixedLidarScanStreamBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LidarScanStreamIdentifier(), true);
}

inline bool VerifyLidarScanStreamBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ouster::osf::v2::LidarScanStream>(LidarScanStreamIdentifier());
}

inline bool VerifySizePrefixedLidarScanStreamBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ouster::osf::v2::LidarScanStream>(LidarScanStreamIdentifier());
}

inline void FinishLidarScanStreamBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ouster::osf::v2::LidarScanStream> root) {
  fbb.Finish(root, LidarScanStreamIdentifier());
}

inline void FinishSizePrefixedLidarScanStreamBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ouster::osf::v2::LidarScanStream> root) {
  fbb.FinishSizePrefixed(root, LidarScanStreamIdentifier());
}

}  // namespace v2
}  // namespace osf
}  // namespace ouster

#endif  // FLATBUFFERS_GENERATED_LIDARSCANSTREAM_OUSTER_OSF_V2_H_
